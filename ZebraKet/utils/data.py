# Class to manage data (for example, loading data from csv, generating mock data etc)
from math import prod
import pandas as pd
import numpy as np
import random
import os
import time
from config import data_dir, missing_product_price

def generate_mock_data(number_products: int=10, number_suppliers:int=10, save_name=None):
    """Generates dataframe for cost per supplier

    Input Paramaters: 
    int number_products -- Number of products to mock
    int number_suppliers -- Number of suppliers to mock
    float markup -- Amount of markup for each item (used when calculating the price)
    
    Returns: 
    Cost Dataframe (rows = suppliers, columns = products)
    """

    # Cost Matrix
    # random.seed(a=1, version=2)
    cost = np.zeros((number_suppliers, number_products)) + missing_product_price
    #cost of all items for every supplier
    for i in range(number_products):
        # base cost used to calculate the cost of the item at each supplier
        cost_base = random.random() * 25
        for supplier in range (number_suppliers):
            # There will be a 25% chance that a given supplier does not have a product 
            if random.random() > 0.25:
                #Cost of item fluctuates from c_base 
                cost[supplier, i] = random.randint(90,130) / 100 * cost_base
    
    cost_df = pd.DataFrame(cost, index=[f'supplier{i}' for i in range(number_suppliers)], columns=[f'item{i}' for i in range(number_products)])

    default_save_name = f'-n_products_{number_products}-n_suppliers_{number_suppliers}-{time.strftime("%Y%m%d-%H%M%S")}.csv'
    cost_filename = f'cost{default_save_name}' if save_name is None else save_name
    cost_data_dir = os.path.join(data_dir, cost_filename)

    if not os.path.isdir(data_dir):
        print(f'Creating data directory: {data_dir}')
        os.makedirs(data_dir)

    print(f'Saving cost data to {cost_data_dir}')

    cost_df.to_csv(cost_data_dir)

    return cost_df

def parse_profit_dataframe(data: pd.DataFrame) -> list[list[str], list[float], list[float]]:
    """Creates the profit dataframe

    Keyword arguments:
    data -- DataFrame containing profit and cost for each product. There must be a "profit" row and "cost" row in the dataframe
    
    Returns:
    Tuple of product names (str)
    Tuple of product cost (float)
    Tuple of product profit (price - cost) (float)

    Example input: 

            | apples | bananas 
    price   | 6.5    | 7.1
    cost    | 2.5    | 2.4
    """
    cost = list(data.loc['cost']) 
    price = list(data.loc['price'])
    profit = [p - c for p, c in zip(price, cost)]
    return list(data), cost, profit

def read_inventory_optimization_data(cost_file:str) -> tuple[list, list[set]]: 
    """Reads cost csv (from generate_mock_data) and converts it into a tuple suitable for use in the supplier optimization formulation

    Params:
    str cost_file -- filepath to the cost matrix

    Returns:
    list of products (our inventory),
    list of sets of products (each set is the inventory of a particular supplier)
    """
    cost_df = pd.read_csv(cost_file, index_col=0)
    cost_np = np.array(cost_df)
    product_names = cost_df.columns
    supplier_names = cost_df.index
    
    supplier_inventories = []
    for supplier_idx in range(len(supplier_names)):
        idx_in_stock = np.where(cost_np[supplier_idx] != missing_product_price)
        supplier_inventories.append(set([product_names[idx] for idx in idx_in_stock[0]]))

    return product_names, supplier_inventories

def read_profit_optimization_data(cost_file:str, selected_suppliers:list[str or int]=None, markup=2.4) -> tuple[list[float], list[float]]:
    """Reads cost and price csv files to return data suitable to be ingested in the profit optimization formulation
    
    Params (both files can be generated by generate_mock_data):
    str cost_file -- filepath to the cost matrix
    list[str|int] selected_suppliers -- if we know what suppliers we will take, we use this to specify them and deduce the price we charge based on their costs
                                        if this is not specified, we deduce the price we charge based on the maximum costs for all suppliers
    float markup -- amount of markup to apply to the found cost (i.e. price = markup*cost)

    Returns
    List of floats indicating the profit per item
    List of floats indicating the cost per item
    """
    cost_dataframe = pd.read_csv(cost_file, index_col=0)
    
    if selected_suppliers is None: 
        # Determine the price we charge based on the maximum cost for every supplier
        cost_array = np.array(cost_dataframe)
        cost = np.amax(cost_array, axis=0) 
    else: 
        # Determine the price we charge based on the minimum cost from the selected suppliers
        cost_array = np.array(cost_dataframe.loc[selected_suppliers])
        cost = np.amin(cost_array, axis=0)
        
    price = [p*markup for p in cost]
    profit = [p - c for p, c in zip(price, cost)]

    return profit, cost


if __name__ == "__main__":

    # # Example usage creating data
    # cost_dataframe, price_dataframe = generate_mock_data(20, 10)
    # print('Cost DataFrame:\n', cost_dataframe, '\n')

    # print('Price DataFrame:\n', price_dataframe, '\n')

    # from config import standard_mock_data
    # p1 = pd.read_csv(standard_mock_data['small']['price'], index_col=0)
    # print(p1)

    # # Example usage reading data for the inventory problem
    # inventory, supplier_inventories = read_inventory_optimization_data('data/small-cost-mock.csv')
    # print('\nMy desired inventory', inventory)
    # print('\n\nSupplier inventories', supplier_inventories)

    # # Example usage reading data for the profit optimization problem
    profit, cost = read_profit_optimization_data('data/small-cost-mock.csv')
    print('\nProfit', profit)
    print('\nCost', cost)